<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>青丝与千纸鹤</title>
      <link href="/2023/12/17/%E9%9D%92%E4%B8%9D%E4%B8%8E%E5%8D%83%E7%BA%B8%E9%B9%A4/"/>
      <url>/2023/12/17/%E9%9D%92%E4%B8%9D%E4%B8%8E%E5%8D%83%E7%BA%B8%E9%B9%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 记忆碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目展示</title>
      <link href="/2023/11/11/%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA/"/>
      <url>/2023/11/11/%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h1><p>一、用anaconda进行包管理<a href="http://8.130.141.48/index.php/2023/09/22/tensorflow_1%e7%94%a8anaconda%e6%90%ad%e5%bb%batensorflow-gpu%e7%8e%af%e5%a2%83/">大佬的教程</a><br>二、<a href="https://dsylxt.github.io/2023/10/03/Python%E7%88%AC%E8%99%AB/">python爬虫</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件下载及激活</title>
      <link href="/2023/10/24/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%8A%E6%BF%80%E6%B4%BB/"/>
      <url>/2023/10/24/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8F%8A%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="关于此篇"><a href="#关于此篇" class="headerlink" title="关于此篇"></a>关于此篇</h1><p>本篇是鼠鼠下载各类软件及激活的一些心得，希望能对大家有帮助<br><strong>面对纯小白，大佬慢走哈</strong></p><p><strong>必备先前条件</strong><br>电脑安装有百度网盘，WinRAR。windows用户名为英文，安装软件的路径不要有任何中文（非常重要！！！）<br>安装的时候遇到各种问题先百度！！！信息检索能力很重要！！！</p><p><a href="http://www.winrar.com.cn/">winrar中文站</a><br>winrar是解压和压缩软件，下载好后这个软件就不用理会了，不需要找到它</p><p><strong>百度网盘不限速下载方式</strong><br>进入百度网盘点击<strong>设置</strong>—&gt;<strong>传输</strong>，并找到<strong>优化速率</strong>选项，选择这一行的按钮<strong>去开启该功能</strong><br>根据鼠鼠的经验，这一方法只对部分类型文件有效，PDF和MP4文件很可能无法加速</p><h2 id="大部分专业软件下载方式"><a href="#大部分专业软件下载方式" class="headerlink" title="大部分专业软件下载方式"></a>大部分专业软件下载方式</h2><p><strong>官网直接下载</strong><br>大部分专业软件提供community版本和professional版本，消费者版一般是免费的，不需要后续的激活，功能也相对少一些，但日常学习是足够的。关键是你必须找到正确的官方网站，下面给一些示例，专业软件的官网长什么样。<br><a href="https://visualstudio.microsoft.com/zh-hans/vs/">vs 2022官网</a><br><a href="https://code.visualstudio.com/">vs code 2022官网</a><br><a href="https://ww2.mathworks.cn/products/matlab.html">matlab 官网</a><br><a href="about:blank">pycharm 官网</a><br>找到对应官网后下载所需版本就好了</p><p><strong>特殊渠道下载</strong><br>许多专业软件往往需要购买正版激活码才可长期使用，提供几种常用方法</p><p>一、搜索引擎直接搜索，大家伙能找到资源就不用看鼠鼠这篇了，大多数鼠鼠都是跑到各种奇奇怪怪的网站里下到奇奇怪怪的应用，那种什么<strong>XX软件园</strong>，<strong>加速下载器</strong>你们搞不定。鼠鼠小时候也是捏，电脑里天天都是2345大战360，小鸟壁纸和盗版传奇争抢桌面，不知搞崩多少次电脑，重装多少次系统。</p><p>二、微信公众号关注“软件管家”，这里提供常见软件的下载和激活<a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzA4MjU4MTg2Ng==&hid=18&sn=2dccf8223c0bac443c2b8f260731278a&uin=&key=&devicetype=Windows+11+x64&version=6309071d&lang=zh_CN&ascene=15&session_us=gh_afcf475b274b">软件管家下载页面</a></p><p>三、B站直接搜索，比如你要激活office，你就去B站找office激活教程，视频往往比文档好懂。<br>要学会看评论区，你能遇到的问题网友们也会遇到，去评论区往往能找到你想要的答案。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pc端操作入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾佬经验贴</title>
      <link href="/2023/10/18/%E5%9E%83%E5%9C%BE%E4%BD%AC%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>/2023/10/18/%E5%9E%83%E5%9C%BE%E4%BD%AC%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2023/10/03/Python%E7%88%AC%E8%99%AB/"/>
      <url>/2023/10/03/Python%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h2><p>向网站发送Get请求获取页面html码，通过解析html码获取自己想要的信息</p><h3 id="几个步骤"><a href="#几个步骤" class="headerlink" title="几个步骤"></a>几个步骤</h3><p>1.根据url获取HTML数据<br>2.解析HTML，获取目标信息(<a href="https://www.runoob.com/html/html-tutorial.html">html教程</a>)<br>3.处理并存储数据</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>#导包import requests from bs4 import BeautifulSoup  # 伪装浏览器head = &#123;    &quot;User-Agent&quot;: &quot;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122  Safari / 537.36&quot;    &#125;# response = requests.get(&quot;https://movie.douban.com/top250?start=0&quot;, headers=head) 第一页# 循环遍历每一页数据for start_num in range(0,250,25):#25为步长,每一页有25部电影，获取前十页    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=head)    html = response.text #保存获取的HTML         soup = BeautifulSoup(html,&quot;html.parser&quot;)    all_title = soup.find_all(&quot;span&quot;, attrs=&#123;&quot;class&quot;:&quot;title&quot;&#125;)    for title in all_title:        # print(title) #打印看看        # print(title.string)        title_string = title.string        if &quot;/&quot; not in title_string:            print(title_string)#拿到某一页 </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变分不等式的物理信息神经网络方法(PINN)</title>
      <link href="/2023/09/21/%E5%8F%98%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E7%89%A9%E7%90%86%E4%BF%A1%E6%81%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/21/%E5%8F%98%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E7%89%A9%E7%90%86%E4%BF%A1%E6%81%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><p>本质上依然是神经网络，但是又把物理方程作为限制加入神经网络中使训练的结果满足物理规律。通过把物理方程的迭代前后的差值加到神经网络的损失函数里面去，让物理方程也“参与”到了训练过程。这样，神经网络在训练迭代时候优化的不仅仅是网络自己的损失函数，还有物理方程每次迭代的差，使得最后训练出来的结果就满足物理规律。</p><h2 id="网上抄的小例子"><a href="#网上抄的小例子" class="headerlink" title="网上抄的小例子"></a>网上抄的小例子</h2><pre><code>import torchimport numpy as npimport matplotlib.pyplot as pltimport torch.nn as nnimport torch.optim as optim# 创建一个简单的偏微分方程def true_solution(x):    return np.sin(np.pi * x)def pde(x, u, du_dx):    return -torch.exp(u) * du_dx - torch.sin(np.pi * x)# 生成训练数据x_train = np.random.rand(100, 1)u_true = true_solution(x_train)du_dx_true = np.pi * np.cos(np.pi * x_train)f_true = pde(x_train, u_true, du_dx_true)x_train = torch.from_numpy(x_train).float()u_true = torch.from_numpy(u_true).float()du_dx_true = torch.from_numpy(du_dx_true).float()f_true = torch.from_numpy(f_true).float()# 构建 PINN 模型class PINN(nn.Module):    def __init__(self):        super(PINN, self).__init__()        self.net = nn.Sequential(            nn.Linear(1, 50),            nn.Tanh(),            nn.Linear(50, 50),            nn.Tanh(),            nn.Linear(50, 1),        )        def forward(self, x):        return self.net(x)# 训练 PINN 模型model = PINN()optimizer = optim.Adam(model.parameters(), lr=0.001)criterion = nn.MSELoss()epochs = 5000for epoch in range(epochs):    optimizer.zero_grad()    u_pred = model(x_train)    du_dx_pred = torch.autograd.grad(u_pred, x_train, grad_outputs=torch.ones_like(u_pred), create_graph=True)[0]    f_pred = pde(x_train, u_pred, du_dx_pred)    loss = criterion(u_pred, u_true) + criterion(f_pred, f_true)    loss.backward()    optimizer.step()        if epoch % 100 == 0:        print(f&quot;Epoch [&#123;epoch&#125;/&#123;epochs&#125;], Loss: &#123;loss.item()&#125;&quot;)# 可视化结果x_test = np.linspace(0, 1, 100).reshape(-1, 1)x_test = torch.from_numpy(x_test).float()u_pred = model(x_test).detach().numpy()plt.figure(figsize=(12, 5))plt.plot(x_test, u_pred, label=&#39;Predicted&#39;)plt.plot(x_test, true_solution(x_test), label=&#39;True&#39;)plt.xlabel(&#39;x&#39;)plt.ylabel(&#39;u&#39;)plt.legend()plt.show()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 大创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠鼠的第一次数模比赛</title>
      <link href="/2023/09/12/%E9%BC%A0%E9%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%95%B0%E6%A8%A1%E6%AF%94%E8%B5%9B/"/>
      <url>/2023/09/12/%E9%BC%A0%E9%BC%A0%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%95%B0%E6%A8%A1%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h2><p>好像是今年四月份吧，jxy跟我谈了认证杯组队的事，我对这类比赛的了解仅仅是听说过，没有任何知识储备，她告诉我要多去尝试。也是从这时开始，一直碌碌无为的鼠鼠决定去尝试，去挑战。最后因为种种原因我们没有任何合作，但还是很感谢她。</p><p>然后五月份的校赛吧，鼠鼠主打一个参与感，没有任何准备就去参加了。结果嘛，是根本没有参赛哈哈哈，因为我报名信息没提交，幸好我的队友也根本不打算玩这个比赛，校赛什么都没发生，我就看了看题目。</p><p>校赛期间吧，基地也不少hxd也参赛了，我就到处转转。最佩服的就是贤宝了，真的一个人带动一支队伍，把俩队友当挂件。不会python就用c语言去处理矩阵，不会算法那就现学，时间不够那就都别睡了，我称之为神。</p><p>校赛你没打，那肯定连国赛的参赛资格都没有，但是没关系，我队友参加了就行。</p><p>当鼠鼠看着hxd们晋级国赛也是相对的羡慕呀，让鼠鼠能成功参赛的关键人物：zby学姐出现了，也不知道是什么原因，不知道为什么，再一次有人找我参赛，虽然我没有竞赛经验，没有拿得出手的本事，但是在我巧妙的沟通（chui niu bi）下，最后成功组队，冲击国赛。</p><h2 id="没有什么准备的准备阶段"><a href="#没有什么准备的准备阶段" class="headerlink" title="没有什么准备的准备阶段"></a>没有什么准备的准备阶段</h2><p>完全不懂算法只有一点点编程语言基础的萌新选手，想去找点入门资料，各类网站的资料五花八门，看来看去都没有满意的课程，最后又是zby发来的清风网课资料，真的是给我全程安排好了，然后就是从零开始学数模。</p><p>学习笔记什么的也在主页了，哈哈哈哈，又是半途而废的一篇，我就没有学精过某样东西。但是不管怎么样，还是学到了点东西吧，数据分析，各种预测，python，matlab什么的多少会了一点。暑假的时候我们计划好一天看一篇论文同时学习算法什么的，不知道为什么又中断了，战犯是谁我也不知道。主要是暑假各种破事太多了，根本没有好好学习，算是荒废一个暑假吧。</p><p>开学后状态回来了但又是军训期间也没学到什么，收集点资料，看看数据分析题论文，实操了一些代码吧，总感觉什么都没准备好，对论文的架构不是很清楚，实操能力也很弱。</p><h2 id="比赛开始咯"><a href="#比赛开始咯" class="headerlink" title="比赛开始咯"></a>比赛开始咯</h2><p>拿到题目后照例每题都看了遍，一开始也有过选B题的想法，但是感觉不熟悉且没什么知识储备还是放弃了，决定做熟悉的数据分析。</p><h4 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h4><p>一打开就是87w行的超大电子表格，四个附件轮着切换真的是头晕眼花，第一个晚上给各类商品匹配编号，销量，价格，不知不觉一个晚上就过去了。</p><p>第二天一大早就拿着匹配好的数据去题，然后发现根本找不到合适的模型，各种异常值也是非常难以处理，以为是数据出问题又从新洗数据。那几天光是洗数据的时间保守估计得有二十小时。<br>基本是软件的操作和代码都是现学现用，全程面对GPT和百度处理数据，excle的函数，matlab代码，spss变量替换……还有各种bug和软件崩溃是真的很烦。</p><p>写累了就出去转转，困了就睡会，饿了就吃几个小面包，时间过得很快。我感觉在场的选手都是在发疯的边缘，自己幸幸苦苦处理的数据也没法得到满意的结果。这三天基本是没怎么见过太阳，晚上一两点回去一大早又继续写题，我也不知道怎么坚持下来的，有一种很亢奋的感觉。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>鏖战三天也没有把题目做得很好，最后也是东拼西凑把论文给写完了，粗略看起来还像点样子，lyh也是跟GPT聊了两天，我也没仔细看最后结果怎么样，希望他的遗传算法能有好的效果。交了论文后连呼吸都变得通畅，所有的疲惫都在这一刻涌上来。然后就是感觉就是很饿，已经一天多没有正常吃饭了，从基地出来又遇上大雨，真的是百感交集。</p><p>这次比赛怎么说呢，我应该是休息最多的吧。俩队友从第二天早上开始就没怎么休息过，lzx三天就睡了不到十小时，总是有人比你更努力。</p><p>毛概课上跟贤宝聊了很久，题目确实有难度，数据不好弄，相关性极弱非常的反常。我一直觉得lzx准备如此充分应该能有不错的结果，不管怎样，我感觉他的论文比我们的更好。</p><h3 id="挺迷茫的"><a href="#挺迷茫的" class="headerlink" title="挺迷茫的"></a>挺迷茫的</h3><p>鼠鼠大一进基地后就开始尝试各种方向，可惜都没有拿得出手的结果，东搞西搞成绩还不好，心不专一终究难成大事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 记忆碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写下此篇，记录往事</title>
      <link href="/2023/09/01/%E5%86%99%E4%B8%8B%E6%AD%A4%E7%AF%87%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%BE%80%E4%BA%8B/"/>
      <url>/2023/09/01/%E5%86%99%E4%B8%8B%E6%AD%A4%E7%AF%87%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%BE%80%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="人们只会对强者的过往感兴趣，待我功成名就"><a href="#人们只会对强者的过往感兴趣，待我功成名就" class="headerlink" title="人们只会对强者的过往感兴趣，待我功成名就"></a>人们只会对强者的过往感兴趣，待我功成名就</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 记忆碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模</title>
      <link href="/2023/06/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/06/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h3><pre><code>评价类问题（打分）例：旅游目的地选择，考虑多方因素</code></pre><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><pre><code>确定目标层，准则层，方案层制定判断矩阵计算一致性指标进行一致性检验计算权重并归一化&#123;    算术平均    几何平均    特征值法&#125;汇总结果计算得分</code></pre><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><pre><code>评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大.</code></pre><h2 id="TOPSIS法-优劣解距离法"><a href="#TOPSIS法-优劣解距离法" class="headerlink" title="TOPSIS法(优劣解距离法)"></a>TOPSIS法(优劣解距离法)</h2><h3 id="适用-1"><a href="#适用-1" class="headerlink" title="适用"></a>适用</h3><pre><code>对对象各方面参数进行衡量，对对象进行评价例：有几个人的成绩和人品参数，对这几个人进行综合评价</code></pre><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><pre><code>构造评分统一指标类型（正向化，标准化）计算得分并归一化带权重的：用层次分析法或熵权法确定权重</code></pre><h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><h3 id="适用-2"><a href="#适用-2" class="headerlink" title="适用"></a>适用</h3><pre><code>进行分析时，数据量不足以支持分析，产生一些靠谱的数据插入短期预测</code></pre><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><pre><code>多项式法：    生成n次多项式经过所有的点    缺点：高次多项式产生ronge现象，在首尾处误差较大分段插值：    分段二次插值    分段三次插值：        Hermite插值法    三次样条插值    三角插值</code></pre><h2 id="拟合算法"><a href="#拟合算法" class="headerlink" title="拟合算法"></a>拟合算法</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code>拟合的结果是得到一个确定的曲线，尽管这条曲线不能经过每一个样本点，但只要保证误差足够小即可</code></pre><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><pre><code>最小二乘法，计算拟合优度</code></pre><h2 id="典型相关分析"><a href="#典型相关分析" class="headerlink" title="典型相关分析"></a>典型相关分析</h2><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><pre><code>计算最短路径</code></pre><h2 id="多元回归"><a href="#多元回归" class="headerlink" title="多元回归"></a>多元回归</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><pre><code>最小二乘法</code></pre><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><pre><code>解决二分类问题（梯度下降）多分类问题：Fisher线性判别分析，逻辑回归</code></pre><h2 id="灰色预测模型"><a href="#灰色预测模型" class="headerlink" title="灰色预测模型"></a>灰色预测模型</h2><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><pre><code>（1）数据是以年份度量的非负数据（如果是月份或者季度数据一定要用我们上一讲学过的时间序列模型）（2）数据能经过准指数规律的检验（除了前两期外，后面至少90%的期数的光滑比要低于0.5）（3）数据的期数较短且和其他数据之间的关联性不强（小于等于10，也不能太短了，比如只有3期数据），要是数据期数较长， 一般用传统的时间序列模型合适</code></pre><h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><pre><code>（1）看到数据后先画时间序列图并简单的分析下趋势（例如：我们上一讲学过的时间序列分解）（2）将数据分为训练组和试验组，尝试使用不同的模型对训练组进行建模，并利用试验组的数据判断哪种模型的预测效果最好（比如我们可以使用SSE 这个指标来挑选模型，常见的模型有指数平滑、ARIMA、灰色预测、神经网络等）（3）选择上一步骤中得到的预测误差最小的那个模型，并利用全部数据来重新建模，并对未来的数据进行预测</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/02/11/%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/02/11/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>思路： 先用折半查找找到应该插入的位置，再移动元素；</p><p>为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 A[mid] &#x3D;&#x3D; A[0] 时，应继续在mid所指位置右边寻找插入位置</p><p>当low&gt;high时，折半查找停止，应将[low,i-1]or[high+1,i-1]内的元素全部右移，并将A[0]复制到low所指的位置；</p><p>代码实现</p><p>void InsertSort(int A[], int n){<br>    int i,j,low,high,mid;<br>    for(i&#x3D;2;i&lt;&#x3D;n;i++){<br>        A[0] &#x3D; A[i];                    &#x2F;&#x2F;将A[i]暂存到A[0]<br>        low &#x3D; 1; high &#x3D; i-1;            &#x2F;&#x2F;折半查找的范围</p><pre><code>    while(low&lt;=high)&#123;               //折半查找        mid = (low + high)/2;       //取中间点        if(A[mid]&gt;A[0])             //查找左半子表            high = mid - 1;        else                        //查找右半子表            low = mid + 1;    &#125;        for(j=i-1; j&gt;high+1;--j)       //统一后移元素，空出插入位置        A[j+1] = A[j];    A[high+1] = A[0]&#125;</code></pre><p>}</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思路： 先追求表中元素的部分有序，再逐渐逼近全局有序；</p><p>更适用于基本有序的排序表和数据量不大的排序表，仅适用于线性表为顺序存储的情况</p><p>代码实现：</p><p>void ShellSort(ElemType A[], int n){<br>    &#x2F;&#x2F;A[0]为暂存单元<br>    for(dk&#x3D;n&#x2F;2; dk&gt;&#x3D;1; dk&#x3D;dk&#x2F;2)   &#x2F;&#x2F;步长递减（看题目要求，一般是1&#x2F;2<br>        for(i&#x3D;dk+1; i&lt;&#x3D;n; ++i)<br>            if(A[i]&lt;A[i-dk]){<br>                A[0]&#x3D;A[i];<br>                for(j&#x3D;i-dk; j&gt;0&amp;&amp;A[0]&lt;A[j];j-&#x3D;dk)<br>                    A[j+dk]&#x3D;A[j];          记录后移，查找插入的位置<br>                A[j+dk]&#x3D;A[0;]              插入<br>            }<br>}</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>略</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>每一趟排序都可使一个中间元素确定其最终位置<br>用一个元素（不一定是第一个）把待排序序列“划分”为两个部分，左边更小，右边更大，该元素的最终位置已确认<br>算法实现（重点）<br>&#x2F;&#x2F;用第一个元素将待排序序列划分为左右两个部分<br>int Partition(int A[], int low, int high){<br>    int pivot &#x3D; A[low];          &#x2F;&#x2F;用第一个元素作为枢轴<br>    while(low&lt;high){<br>        while(low &lt; high &amp;&amp; A[high]&gt;&#x3D;pivot) –high; &#x2F;&#x2F;high所指元素大于枢轴，high左移<br>        A[low] &#x3D; A[high];   &#x2F;&#x2F;high所指元素小于枢轴，移动到左侧</p><pre><code>    while(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low; //low所指元素小于枢轴，low右移    A[high] = A[low];   //low所指元素大于枢轴，移动到右侧&#125;A[low] = pivot   //枢轴元素存放到最终位置return low；     //返回存放枢轴的最终位置</code></pre><p>} </p><p>&#x2F;&#x2F;快速排序<br>void QuickSort(int A[], int low, int high){<br>    if(low&lt;high)    递归跳出条件<br>        int pivotpos &#x3D; Partition(A, low, high);    划分<br>        QuickSort（A, low, pivotpos - 1);     划分左子表<br>        QuickSort（A, pivotpos + 1, high);    划分右子表<br>}</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>void swap(int &amp;a, int &amp;b){<br>    int temp &#x3D; a;<br>    a &#x3D; b;<br>    b &#x3D; temp;<br>}</p><p>void SelectSort(int A[], int n){       &#x2F;&#x2F;A从0开始<br>    for(int i&#x3D;0; i&lt;n-1; i++){           一共进行n-1趟，i指向待排序序列中第一个元素<br>        int min &#x3D; i;                   记录最小元素位置<br>        for(int j&#x3D;i+1; j&lt;n; j++)        在A[i…n-1]中选择最小的元素<br>            if(A[j] &lt;&gt; A [min]) min &#x3D; j;   &#x2F;&#x2F; 更新最小元素位置<br>        if(min!&#x3D;i)<br>            swao(A[i],A[min]);         &#x2F;&#x2F; 交换<br>    }<br>}</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把两个或多个已经有序的序列合并成一个<br>&#x2F;&#x2F;创建辅助数组B<br>int *B&#x3D;(int <em>)malloc(n</em>sizeof(int));</p><p>&#x2F;&#x2F;A[low,…,mid],A[mid+1,…,high] 各自有序，将这两个部分归并<br>void Merge(int A[], int low, int mid, int high){<br>    int i,j,k;<br>    for(k&#x3D;low; k&lt;&#x3D;high; k++)<br>        B[k] &#x3D; A[k];           &#x2F;&#x2F;将A中所有元素复制到B中<br>    for(i&#x3D;low, j&#x3D;mid+1, k&#x3D;i; i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D; high; k++){<br>        if(B[i]&lt;&#x3D;B[j])          &#x2F;&#x2F;为保证稳定性两个元素相等时，优先使用靠前的那个<br>            A[k]&#x3D;B[i++];        &#x2F;&#x2F;将较小值复制到A中<br>        else<br>            A[k]&#x3D;B[j++];<br>    }&#x2F;&#x2F;for</p><pre><code>//没有归并完的部分复制到尾部，while只会执行一个 while(i&lt;=mid)  A[k++]=B[i++];     //若第一个表未检测完，复制while(j&lt;=high) A[k++]=B[j++];     //若第二个表未检测完，复制</code></pre><p>}</p><p>&#x2F;&#x2F;递归操作<br>void MergeSort(int A[], int low, int high){<br>    if(low&lt;high){<br>        int mid &#x3D; (low+high)&#x2F;2;     从中间划分<br>        MergeSort(A, low, mid);     对左半部分归并排序<br>        MergeSort(A, mid+1, high);  对右半部分归并排序<br>        Merge(A,low,mid,high);      归并<br>    }if<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2023/02/11/%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/11/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2023/02/11/%E5%9B%BE/"/>
      <url>/2023/02/11/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作受限线性表</title>
      <link href="/2023/02/11/%E6%93%8D%E4%BD%9C%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/11/%E6%93%8D%E4%BD%9C%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>只允许在一端进行插入或删除操作的线性表<br>操作与普通顺序表区别不大<br>特点：先进后出，后进先出</p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>#define MaxSize 10         &#x2F;&#x2F;定义栈中元素的最大个数</p><p>typedef struct{<br>    ElemType data[MaxSize];       &#x2F;&#x2F;静态数组存放栈中元素<br>    int top;                      &#x2F;&#x2F;栈顶元素<br>}SqStack;</p><p>&#x2F;&#x2F;初始化栈<br>void InitStack(SqStack &amp;S){<br>    S.top &#x3D; -1;                   &#x2F;&#x2F;初始化栈顶指针<br>}</p><p>&#x2F;&#x2F;判栈空<br>bool StackEmpty(SqStack S){<br>    if(S.top &#x3D;&#x3D; -1)      &#x2F;&#x2F;栈空<br>        return true;<br>    else                 &#x2F;&#x2F;栈不空<br>        return false;<br>}</p><p>&#x2F;&#x2F;新元素进栈<br>bool Push(SqStack &amp;S, ElemType x){<br>    if(S.top &#x3D;&#x3D; MaxSize - 1)        &#x2F;&#x2F;栈满<br>        return false;</p><pre><code>S.top = S.top + 1;    //指针先加1S.data[S.top] = x;    //新元素入栈/*S.data[++S.top] = x;*/return true;</code></pre><p>}</p><p>&#x2F;&#x2F;出栈<br>bool Pop(SqStack &amp;x, ElemType &amp;x){<br>    if(S.top &#x3D;&#x3D; -1)          &#x2F;&#x2F;栈空<br>        return false;</p><pre><code>x = S.data[S.top];       //先出栈S.top = S.top - 1;       //栈顶指针减1return true;/*x = S.data[S.top--];*///只是逻辑上的删除，数据依然残留在内存里</code></pre><p>}</p><p>&#x2F;&#x2F;读栈顶元素<br>bool GetTop(SqStack S, ElemType &amp;x){<br>    if(S.top &#x3D;&#x3D; -1)<br>        return false;</p><pre><code>x = S.data[S.top];      //x记录栈顶元素return true; </code></pre><p>}</p><p>void testStack(){<br>    SqStack S;       &#x2F;&#x2F;声明一个顺序栈(分配空间)<br>    InitStack(S);<br>    &#x2F;&#x2F;…<br>}</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>与单链表相同<br>typedef struct Linknode{<br>    ElemType data;              &#x2F;&#x2F;数据域<br>    struct Linknode *next;      &#x2F;&#x2F;指针域<br>}*LiStack;                      &#x2F;&#x2F;栈类型的定义</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>只允许从两端插入、两端删除的线性表<br>输入受限的双端队列：只允许从一端插入、两端删除的线性表<br>输出受限的双端队列：只允许从两端插入、一端删除的线性表</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/02/10/%E6%A0%91/"/>
      <url>/2023/02/10/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉树的遍历<br>先序<br>typedef struct BiTnode{<br>ElemType data;<br>struct BiTNode *lchild, *rchild;<br>}BiTNode, *BiTree;</p><p>void PreOrder(BiTree T){<br>if(T!&#x3D;NULL){<br>    visit(T);                 &#x2F;&#x2F;访问根结点（可改变访问顺序、中序、后序）<br>    PreOrder(T-&gt;lchild);      &#x2F;&#x2F;递归遍历左子树<br>    PreOrder(T-&gt;rchild);      &#x2F;&#x2F;递归遍历右子树<br>}<br>}</p><p>层序遍历</p><p>一个队列<br>层层入队</p><p>typedef struct BiTnode{<br>ElemType data;<br>struct BiTNode *lchild, *rchild;<br>}BiTNode, *BiTree;</p><p>&#x2F;&#x2F;链式队列结点<br>typedef struct LinkNode{<br>BiTNode * data;<br>typedef LinkNode *next;<br>}LinkNode;</p><p>typedef struct{<br>LinkNode *front, *rear;<br>}LinkQueue;</p><p>&#x2F;&#x2F;主函数<br>void LevelOrder(BiTree T){<br>LinkQueue Q;<br>InitQueue (Q);          &#x2F;&#x2F;初始化辅助队列<br>BiTree p;<br>EnQueue(Q,T);           &#x2F;&#x2F;将根节点入队<br>while(!isEmpty(Q)){     &#x2F;&#x2F;队列不空则循环<br>    DeQueue(Q,p);        &#x2F;&#x2F;队头结点出队<br>    visit(p);            &#x2F;&#x2F;访问出队结点<br>    if(p-&gt;lchild !&#x3D; NULL)<br>        EnQueue(Q,p-&gt;lchild);   &#x2F;&#x2F;左孩子入队<br>    if(p-&gt;rchild !&#x3D; NULL)<br>        EnQueue(Q,p-&gt;rchild);   &#x2F;&#x2F;右孩子入队<br>}<br>}</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>二叉树线索化：先序、中序、后序。</p><p>typedef struct ThreadNode{<br>int data;<br>struct ThreadNode *lchild, *rchild;<br>int ltag, rtag;                &#x2F;&#x2F; 左、右线索标志<br>}ThreadNode, *ThreadTree;</p><p>&#x2F;&#x2F;全局变量pre, 指向当前访问的结点的前驱<br>TreadNode *pre&#x3D;NULL;</p><p>&#x2F;&#x2F;先序遍历二叉树，一边遍历一边线索化<br>void PreThread(ThreadTree T){<br>if(T!&#x3D;NULL){<br>    visit(T);<br>    if(T-&gt;ltag &#x3D;&#x3D; 0)         &#x2F;&#x2F;lchild不是前驱线索<br>        PreThread(T-&gt;lchild);<br>    PreThread(T-&gt;rchild);<br>}<br>}</p><p>void visit(ThreadNode *q){<br>if(q-&gt;lchid &#x3D; NULL){                 &#x2F;&#x2F;左子树为空，建立前驱线索<br>    q-&gt;lchild &#x3D; pre;<br>    q-&gt;ltag &#x3D; 1;<br>}</p><p>if(pre!&#x3D;NULL &amp;&amp; pre-&gt;rchild &#x3D; NULL){<br>    pre-&gt;rchild &#x3D; q;           &#x2F;&#x2F;建立前驱结点的后继线索<br>    pre-&gt;rtag &#x3D; 1;<br>}<br>pre &#x3D; q;<br>}</p><p>&#x2F;&#x2F;先序线索化二叉树T<br>void CreateInThread(ThreadTree T){<br>pre &#x3D; NULL;                &#x2F;&#x2F;pre初始为NULL<br>if(T!&#x3D;NULL);{              &#x2F;&#x2F;非空二叉树才能进行线索化<br>    PreThread(T);            &#x2F;&#x2F;先序线索化二叉树<br>    if(pre-&gt;rchild &#x3D;&#x3D; NULL)<br>        pre-&gt;rtag&#x3D;1;         &#x2F;&#x2F;处理遍历的最后一个结点<br>}<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2023/02/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2023/02/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><details><summary>静态顺序表</summary><pre><code>    #include<stdio.h>    #define MaxSize 10//定义最大长度    typedef struct &#123;        int data[MaxSize];//定义静态数组        int length;//顺序表当前长度    &#125;SqList;    <pre><code>void InitList(SqList&amp; L) &#123;    for (int i = 0;i &lt; MaxSize;i++) &#123;        L.data[i] = 0;//所以数据初始值为0    &#125;    L.length = 0;//顺序表初始长度为0&#125;int main() &#123;    SqList L;//声明顺序表    InitList(L);//调用函数，初始化顺序表    return 0;&#125;</code></pre><p></code></pre></p></details>    <span id="more"></span><details><summary>动态分配</summary><pre><code>    #include<stdio.h>    #include<stdlib.h>    #define InitSize 10;    //定义顺序表    typedef struct &#123;        int *data;     //动态数组指针        int MaxSize;   //当前最大容量        int length;    //当前长度    &#125;SeqList;<pre><code>void InitList(SeqList &amp;L) &#123;    L.data = (int*)malloc((L.MaxSize) * sizeof(int));//开辟容量为MaxSize的空间    L.length = 0;//初始化长度    L.MaxSize = InitSize;//最大容量为10&#125;//增加容量void IncreseSize(SeqList&amp; L, int len) &#123;    int* p = L.data;//将数组首项地址赋予*p    L.data = (int*)malloc((L.MaxSize + len) * sizeof(int));//增加len*sizeof(int)长度空间    for (int i = 0;i &lt; L.length;i++) &#123;        L.data[i] = p[i];//将L.data数组中的值转移到新的空间    &#125;    L.MaxSize = L.MaxSize + len;//最大长度增加    free(p);//释放旧存储空间&#125;int main() &#123;    SeqList L;    InitList(L);    for (int i = 0;i &lt; L.MaxSize;i++) &#123;        L.data[i] = 1;    &#125;    IncreseSize(L, 5);//5=len    return 0;&#125;</code></pre><p></code></pre></p></details><details><summary>插入</summary><pre><code>    #include<stdio.h>    #define MaxSize 10//定义最大长度    typedef struct &#123;        int data[MaxSize];//定义静态数组        int length;//顺序表当前长度    &#125;SqList;<pre><code>bool ListInsert(SqList &amp;L, int i, int e) &#123;    if (i&lt;1 || i&gt;L.length)//判断插入位置是否合法        return false;    if (L.length &gt;= MaxSize)//同上        return false;    for (int j = L.length;j &gt;= i;j--)        L.data[j] = L.data[j - 1];//将i后元素后移一位    L.data[i - 1] = e;//插入e    L.length++;//使顺序表当前长度加一    return true;&#125;void InitList(SqList&amp; L) &#123;    for (int i = 0;i &lt; MaxSize;i++) &#123;        L.data[i] = 0;//所以数据初始值为0    &#125;    L.length = 0;//顺序表初始长度为0&#125;int main() &#123;    SqList L;    InitList(L);    //插入元素    ListInsert(L, 3, 3);//在第三个位置插入3    return 0;&#125;</code></pre><p></code></pre></p></details>   <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">基本结构</span><br><span class="line">typedef struct LNode &#123;</span><br><span class="line">int data;</span><br><span class="line">struct LNode* next; //指向下一个结构体。</span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line">void InitList(LinkList &amp;L)&#123;</span><br><span class="line">L = (LNode *)malloc(sizeof(LinkList));申请头指针的内存</span><br><span class="line">L-&gt;next = NULL; 将头指针置空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">尾插法建立单链表</span><br><span class="line">LinkList TailInsert(LinkList &amp;L)&#123;</span><br><span class="line">InitList(L);</span><br><span class="line">LNode *s,*r=L;</span><br><span class="line">int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">while(x!=9999)&#123;</span><br><span class="line">s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = s;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = NULL;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">头插法建立单链表</span><br><span class="line">LinkList HeadInsert(LinkList &amp;L)&#123;</span><br><span class="line">InitList(L); //初始化</span><br><span class="line">int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">while(x!=9999)&#123; </span><br><span class="line">LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历单链表</span><br><span class="line">void PrintList(LinkList L) &#123;</span><br><span class="line">LNode* p = L-&gt;next;</span><br><span class="line">while (p) &#123; //当p指向NULL跳出循环。</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求链表长度</span><br><span class="line">int Length(LinkList L)&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">int len = 0;</span><br><span class="line">while(p)&#123;</span><br><span class="line">len++; //每读取一个节点len自增。</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按值查找</span><br><span class="line">LNode *LocateElem(LinkList L, int x)&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">while(p &amp;&amp; p-&gt;data != x)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按位查找</span><br><span class="line">LNode *GetElem(LinkList L, int i)&#123;</span><br><span class="line">int j=1;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">if(i==0)return L;</span><br><span class="line">if(i&lt;1)return NULL;</span><br><span class="line">while(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">return p; // 如果i大于表长，p=NULL，将返回p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入</span><br><span class="line">void Insert(LinkList &amp;L, int i, int x)&#123;</span><br><span class="line">LNode *p = GetElem(L,i-1);</span><br><span class="line">LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">void Delete(LinkList &amp;L, int i)&#123;</span><br><span class="line">if(i&lt;1 || i&gt;Length(L))</span><br><span class="line">cout&lt;&lt;&quot;delete failed: index is wrong.&quot;&lt;&lt;endl;</span><br><span class="line">return;</span><br><span class="line">LNode *p = GetElem(L,i-1);</span><br><span class="line">LNode *q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">free(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line">bool Empty(LinkList L)&#123;</span><br><span class="line">    if(L-&gt;next == NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;L is null&quot;&lt;&lt;endl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">else&#123;</span><br><span class="line">        cout &lt;&lt;&quot;L is not null&quot;&lt;&lt;endl;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

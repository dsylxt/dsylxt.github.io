<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数学建模三月速成</title>
      <link href="/2023/06/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%89%E6%9C%88%E9%80%9F%E6%88%90/"/>
      <url>/2023/06/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%89%E6%9C%88%E9%80%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h3><p>评价类问题（打分）<br>例：旅游目的地选择，考虑多方因素</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>确定目标层，准则层，方案层<br>制定判断矩阵<br>计算一致性指标进行一致性检验<br>计算权重并归一化<br>{<br>    算术平均<br>    几何平均<br>    特征值法<br>}<br>汇总结果计算得分</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>1评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异<br>可能会很大.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/10/music/index/"/>
      <url>/2023/04/10/music/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2023/02/11/%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/02/11/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>思路： 先用折半查找找到应该插入的位置，再移动元素；</p><p>为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 A[mid] &#x3D;&#x3D; A[0] 时，应继续在mid所指位置右边寻找插入位置</p><p>当low&gt;high时，折半查找停止，应将[low,i-1]or[high+1,i-1]内的元素全部右移，并将A[0]复制到low所指的位置；</p><p>代码实现</p><p>void InsertSort(int A[], int n){<br>    int i,j,low,high,mid;<br>    for(i&#x3D;2;i&lt;&#x3D;n;i++){<br>        A[0] &#x3D; A[i];                    &#x2F;&#x2F;将A[i]暂存到A[0]<br>        low &#x3D; 1; high &#x3D; i-1;            &#x2F;&#x2F;折半查找的范围</p><pre><code>    while(low&lt;=high)&#123;               //折半查找        mid = (low + high)/2;       //取中间点        if(A[mid]&gt;A[0])             //查找左半子表            high = mid - 1;        else                        //查找右半子表            low = mid + 1;    &#125;        for(j=i-1; j&gt;high+1;--j)       //统一后移元素，空出插入位置        A[j+1] = A[j];    A[high+1] = A[0]&#125;</code></pre><p>}</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思路： 先追求表中元素的部分有序，再逐渐逼近全局有序；</p><p>更适用于基本有序的排序表和数据量不大的排序表，仅适用于线性表为顺序存储的情况</p><p>代码实现：</p><p>void ShellSort(ElemType A[], int n){<br>    &#x2F;&#x2F;A[0]为暂存单元<br>    for(dk&#x3D;n&#x2F;2; dk&gt;&#x3D;1; dk&#x3D;dk&#x2F;2)   &#x2F;&#x2F;步长递减（看题目要求，一般是1&#x2F;2<br>        for(i&#x3D;dk+1; i&lt;&#x3D;n; ++i)<br>            if(A[i]&lt;A[i-dk]){<br>                A[0]&#x3D;A[i];<br>                for(j&#x3D;i-dk; j&gt;0&amp;&amp;A[0]&lt;A[j];j-&#x3D;dk)<br>                    A[j+dk]&#x3D;A[j];          记录后移，查找插入的位置<br>                A[j+dk]&#x3D;A[0;]              插入<br>            }<br>}</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>略</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>每一趟排序都可使一个中间元素确定其最终位置<br>用一个元素（不一定是第一个）把待排序序列“划分”为两个部分，左边更小，右边更大，该元素的最终位置已确认<br>算法实现（重点）<br>&#x2F;&#x2F;用第一个元素将待排序序列划分为左右两个部分<br>int Partition(int A[], int low, int high){<br>    int pivot &#x3D; A[low];          &#x2F;&#x2F;用第一个元素作为枢轴<br>    while(low&lt;high){<br>        while(low &lt; high &amp;&amp; A[high]&gt;&#x3D;pivot) –high; &#x2F;&#x2F;high所指元素大于枢轴，high左移<br>        A[low] &#x3D; A[high];   &#x2F;&#x2F;high所指元素小于枢轴，移动到左侧</p><pre><code>    while(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low; //low所指元素小于枢轴，low右移    A[high] = A[low];   //low所指元素大于枢轴，移动到右侧&#125;A[low] = pivot   //枢轴元素存放到最终位置return low；     //返回存放枢轴的最终位置</code></pre><p>} </p><p>&#x2F;&#x2F;快速排序<br>void QuickSort(int A[], int low, int high){<br>    if(low&lt;high)    递归跳出条件<br>        int pivotpos &#x3D; Partition(A, low, high);    划分<br>        QuickSort（A, low, pivotpos - 1);     划分左子表<br>        QuickSort（A, pivotpos + 1, high);    划分右子表<br>}</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>void swap(int &amp;a, int &amp;b){<br>    int temp &#x3D; a;<br>    a &#x3D; b;<br>    b &#x3D; temp;<br>}</p><p>void SelectSort(int A[], int n){       &#x2F;&#x2F;A从0开始<br>    for(int i&#x3D;0; i&lt;n-1; i++){           一共进行n-1趟，i指向待排序序列中第一个元素<br>        int min &#x3D; i;                   记录最小元素位置<br>        for(int j&#x3D;i+1; j&lt;n; j++)        在A[i…n-1]中选择最小的元素<br>            if(A[j] &lt;&gt; A [min]) min &#x3D; j;   &#x2F;&#x2F; 更新最小元素位置<br>        if(min!&#x3D;i)<br>            swao(A[i],A[min]);         &#x2F;&#x2F; 交换<br>    }<br>}</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把两个或多个已经有序的序列合并成一个<br>&#x2F;&#x2F;创建辅助数组B<br>int *B&#x3D;(int <em>)malloc(n</em>sizeof(int));</p><p>&#x2F;&#x2F;A[low,…,mid],A[mid+1,…,high] 各自有序，将这两个部分归并<br>void Merge(int A[], int low, int mid, int high){<br>    int i,j,k;<br>    for(k&#x3D;low; k&lt;&#x3D;high; k++)<br>        B[k] &#x3D; A[k];           &#x2F;&#x2F;将A中所有元素复制到B中<br>    for(i&#x3D;low, j&#x3D;mid+1, k&#x3D;i; i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D; high; k++){<br>        if(B[i]&lt;&#x3D;B[j])          &#x2F;&#x2F;为保证稳定性两个元素相等时，优先使用靠前的那个<br>            A[k]&#x3D;B[i++];        &#x2F;&#x2F;将较小值复制到A中<br>        else<br>            A[k]&#x3D;B[j++];<br>    }&#x2F;&#x2F;for</p><pre><code>//没有归并完的部分复制到尾部，while只会执行一个 while(i&lt;=mid)  A[k++]=B[i++];     //若第一个表未检测完，复制while(j&lt;=high) A[k++]=B[j++];     //若第二个表未检测完，复制</code></pre><p>}</p><p>&#x2F;&#x2F;递归操作<br>void MergeSort(int A[], int low, int high){<br>    if(low&lt;high){<br>        int mid &#x3D; (low+high)&#x2F;2;     从中间划分<br>        MergeSort(A, low, mid);     对左半部分归并排序<br>        MergeSort(A, mid+1, high);  对右半部分归并排序<br>        Merge(A,low,mid,high);      归并<br>    }if<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="/2023/02/11/%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/11/%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2023/02/11/%E5%9B%BE/"/>
      <url>/2023/02/11/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作受限线性表</title>
      <link href="/2023/02/11/%E6%93%8D%E4%BD%9C%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/11/%E6%93%8D%E4%BD%9C%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>只允许在一端进行插入或删除操作的线性表<br>操作与普通顺序表区别不大<br>特点：先进后出，后进先出</p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>#define MaxSize 10         &#x2F;&#x2F;定义栈中元素的最大个数</p><p>typedef struct{<br>    ElemType data[MaxSize];       &#x2F;&#x2F;静态数组存放栈中元素<br>    int top;                      &#x2F;&#x2F;栈顶元素<br>}SqStack;</p><p>&#x2F;&#x2F;初始化栈<br>void InitStack(SqStack &amp;S){<br>    S.top &#x3D; -1;                   &#x2F;&#x2F;初始化栈顶指针<br>}</p><p>&#x2F;&#x2F;判栈空<br>bool StackEmpty(SqStack S){<br>    if(S.top &#x3D;&#x3D; -1)      &#x2F;&#x2F;栈空<br>        return true;<br>    else                 &#x2F;&#x2F;栈不空<br>        return false;<br>}</p><p>&#x2F;&#x2F;新元素进栈<br>bool Push(SqStack &amp;S, ElemType x){<br>    if(S.top &#x3D;&#x3D; MaxSize - 1)        &#x2F;&#x2F;栈满<br>        return false;</p><pre><code>S.top = S.top + 1;    //指针先加1S.data[S.top] = x;    //新元素入栈/*S.data[++S.top] = x;*/return true;</code></pre><p>}</p><p>&#x2F;&#x2F;出栈<br>bool Pop(SqStack &amp;x, ElemType &amp;x){<br>    if(S.top &#x3D;&#x3D; -1)          &#x2F;&#x2F;栈空<br>        return false;</p><pre><code>x = S.data[S.top];       //先出栈S.top = S.top - 1;       //栈顶指针减1return true;/*x = S.data[S.top--];*///只是逻辑上的删除，数据依然残留在内存里</code></pre><p>}</p><p>&#x2F;&#x2F;读栈顶元素<br>bool GetTop(SqStack S, ElemType &amp;x){<br>    if(S.top &#x3D;&#x3D; -1)<br>        return false;</p><pre><code>x = S.data[S.top];      //x记录栈顶元素return true; </code></pre><p>}</p><p>void testStack(){<br>    SqStack S;       &#x2F;&#x2F;声明一个顺序栈(分配空间)<br>    InitStack(S);<br>    &#x2F;&#x2F;…<br>}</p><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>与单链表相同<br>typedef struct Linknode{<br>    ElemType data;              &#x2F;&#x2F;数据域<br>    struct Linknode *next;      &#x2F;&#x2F;指针域<br>}*LiStack;                      &#x2F;&#x2F;栈类型的定义</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>只允许从两端插入、两端删除的线性表<br>输入受限的双端队列：只允许从一端插入、两端删除的线性表<br>输出受限的双端队列：只允许从两端插入、一端删除的线性表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2023/02/10/%E6%A0%91/"/>
      <url>/2023/02/10/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉树的遍历<br>先序<br>typedef struct BiTnode{<br>ElemType data;<br>struct BiTNode *lchild, *rchild;<br>}BiTNode, *BiTree;</p><p>void PreOrder(BiTree T){<br>if(T!&#x3D;NULL){<br>    visit(T);                 &#x2F;&#x2F;访问根结点（可改变访问顺序、中序、后序）<br>    PreOrder(T-&gt;lchild);      &#x2F;&#x2F;递归遍历左子树<br>    PreOrder(T-&gt;rchild);      &#x2F;&#x2F;递归遍历右子树<br>}<br>}</p><p>层序遍历</p><p>一个队列<br>层层入队</p><p>typedef struct BiTnode{<br>ElemType data;<br>struct BiTNode *lchild, *rchild;<br>}BiTNode, *BiTree;</p><p>&#x2F;&#x2F;链式队列结点<br>typedef struct LinkNode{<br>BiTNode * data;<br>typedef LinkNode *next;<br>}LinkNode;</p><p>typedef struct{<br>LinkNode *front, *rear;<br>}LinkQueue;</p><p>&#x2F;&#x2F;主函数<br>void LevelOrder(BiTree T){<br>LinkQueue Q;<br>InitQueue (Q);          &#x2F;&#x2F;初始化辅助队列<br>BiTree p;<br>EnQueue(Q,T);           &#x2F;&#x2F;将根节点入队<br>while(!isEmpty(Q)){     &#x2F;&#x2F;队列不空则循环<br>    DeQueue(Q,p);        &#x2F;&#x2F;队头结点出队<br>    visit(p);            &#x2F;&#x2F;访问出队结点<br>    if(p-&gt;lchild !&#x3D; NULL)<br>        EnQueue(Q,p-&gt;lchild);   &#x2F;&#x2F;左孩子入队<br>    if(p-&gt;rchild !&#x3D; NULL)<br>        EnQueue(Q,p-&gt;rchild);   &#x2F;&#x2F;右孩子入队<br>}<br>}</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>二叉树线索化：先序、中序、后序。</p><p>typedef struct ThreadNode{<br>int data;<br>struct ThreadNode *lchild, *rchild;<br>int ltag, rtag;                &#x2F;&#x2F; 左、右线索标志<br>}ThreadNode, *ThreadTree;</p><p>&#x2F;&#x2F;全局变量pre, 指向当前访问的结点的前驱<br>TreadNode *pre&#x3D;NULL;</p><p>&#x2F;&#x2F;先序遍历二叉树，一边遍历一边线索化<br>void PreThread(ThreadTree T){<br>if(T!&#x3D;NULL){<br>    visit(T);<br>    if(T-&gt;ltag &#x3D;&#x3D; 0)         &#x2F;&#x2F;lchild不是前驱线索<br>        PreThread(T-&gt;lchild);<br>    PreThread(T-&gt;rchild);<br>}<br>}</p><p>void visit(ThreadNode *q){<br>if(q-&gt;lchid &#x3D; NULL){                 &#x2F;&#x2F;左子树为空，建立前驱线索<br>    q-&gt;lchild &#x3D; pre;<br>    q-&gt;ltag &#x3D; 1;<br>}</p><p>if(pre!&#x3D;NULL &amp;&amp; pre-&gt;rchild &#x3D; NULL){<br>    pre-&gt;rchild &#x3D; q;           &#x2F;&#x2F;建立前驱结点的后继线索<br>    pre-&gt;rtag &#x3D; 1;<br>}<br>pre &#x3D; q;<br>}</p><p>&#x2F;&#x2F;先序线索化二叉树T<br>void CreateInThread(ThreadTree T){<br>pre &#x3D; NULL;                &#x2F;&#x2F;pre初始为NULL<br>if(T!&#x3D;NULL);{              &#x2F;&#x2F;非空二叉树才能进行线索化<br>    PreThread(T);            &#x2F;&#x2F;先序线索化二叉树<br>    if(pre-&gt;rchild &#x3D;&#x3D; NULL)<br>        pre-&gt;rtag&#x3D;1;         &#x2F;&#x2F;处理遍历的最后一个结点<br>}<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2023/02/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2023/02/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><details><summary>静态顺序表</summary><pre><code>    #include<stdio.h>    #define MaxSize 10//定义最大长度    typedef struct &#123;        int data[MaxSize];//定义静态数组        int length;//顺序表当前长度    &#125;SqList;    <pre><code>void InitList(SqList&amp; L) &#123;    for (int i = 0;i &lt; MaxSize;i++) &#123;        L.data[i] = 0;//所以数据初始值为0    &#125;    L.length = 0;//顺序表初始长度为0&#125;int main() &#123;    SqList L;//声明顺序表    InitList(L);//调用函数，初始化顺序表    return 0;&#125;</code></pre><p></code></pre></p></details>    <span id="more"></span><details><summary>动态分配</summary><pre><code>    #include<stdio.h>    #include<stdlib.h>    #define InitSize 10;    //定义顺序表    typedef struct &#123;        int *data;     //动态数组指针        int MaxSize;   //当前最大容量        int length;    //当前长度    &#125;SeqList;<pre><code>void InitList(SeqList &amp;L) &#123;    L.data = (int*)malloc((L.MaxSize) * sizeof(int));//开辟容量为MaxSize的空间    L.length = 0;//初始化长度    L.MaxSize = InitSize;//最大容量为10&#125;//增加容量void IncreseSize(SeqList&amp; L, int len) &#123;    int* p = L.data;//将数组首项地址赋予*p    L.data = (int*)malloc((L.MaxSize + len) * sizeof(int));//增加len*sizeof(int)长度空间    for (int i = 0;i &lt; L.length;i++) &#123;        L.data[i] = p[i];//将L.data数组中的值转移到新的空间    &#125;    L.MaxSize = L.MaxSize + len;//最大长度增加    free(p);//释放旧存储空间&#125;int main() &#123;    SeqList L;    InitList(L);    for (int i = 0;i &lt; L.MaxSize;i++) &#123;        L.data[i] = 1;    &#125;    IncreseSize(L, 5);//5=len    return 0;&#125;</code></pre><p></code></pre></p></details><details><summary>插入</summary><pre><code>    #include<stdio.h>    #define MaxSize 10//定义最大长度    typedef struct &#123;        int data[MaxSize];//定义静态数组        int length;//顺序表当前长度    &#125;SqList;<pre><code>bool ListInsert(SqList &amp;L, int i, int e) &#123;    if (i&lt;1 || i&gt;L.length)//判断插入位置是否合法        return false;    if (L.length &gt;= MaxSize)//同上        return false;    for (int j = L.length;j &gt;= i;j--)        L.data[j] = L.data[j - 1];//将i后元素后移一位    L.data[i - 1] = e;//插入e    L.length++;//使顺序表当前长度加一    return true;&#125;void InitList(SqList&amp; L) &#123;    for (int i = 0;i &lt; MaxSize;i++) &#123;        L.data[i] = 0;//所以数据初始值为0    &#125;    L.length = 0;//顺序表初始长度为0&#125;int main() &#123;    SqList L;    InitList(L);    //插入元素    ListInsert(L, 3, 3);//在第三个位置插入3    return 0;&#125;</code></pre><p></code></pre></p></details>   <h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">基本结构</span><br><span class="line">typedef struct LNode &#123;</span><br><span class="line">int data;</span><br><span class="line">struct LNode* next; //指向下一个结构体。</span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line">void InitList(LinkList &amp;L)&#123;</span><br><span class="line">L = (LNode *)malloc(sizeof(LinkList));申请头指针的内存</span><br><span class="line">L-&gt;next = NULL; 将头指针置空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">尾插法建立单链表</span><br><span class="line">LinkList TailInsert(LinkList &amp;L)&#123;</span><br><span class="line">InitList(L);</span><br><span class="line">LNode *s,*r=L;</span><br><span class="line">int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">while(x!=9999)&#123;</span><br><span class="line">s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = s;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = NULL;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">头插法建立单链表</span><br><span class="line">LinkList HeadInsert(LinkList &amp;L)&#123;</span><br><span class="line">InitList(L); //初始化</span><br><span class="line">int x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">while(x!=9999)&#123; </span><br><span class="line">LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历单链表</span><br><span class="line">void PrintList(LinkList L) &#123;</span><br><span class="line">LNode* p = L-&gt;next;</span><br><span class="line">while (p) &#123; //当p指向NULL跳出循环。</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求链表长度</span><br><span class="line">int Length(LinkList L)&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">int len = 0;</span><br><span class="line">while(p)&#123;</span><br><span class="line">len++; //每读取一个节点len自增。</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按值查找</span><br><span class="line">LNode *LocateElem(LinkList L, int x)&#123;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">while(p &amp;&amp; p-&gt;data != x)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">按位查找</span><br><span class="line">LNode *GetElem(LinkList L, int i)&#123;</span><br><span class="line">int j=1;</span><br><span class="line">LNode *p = L-&gt;next;</span><br><span class="line">if(i==0)return L;</span><br><span class="line">if(i&lt;1)return NULL;</span><br><span class="line">while(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">return p; // 如果i大于表长，p=NULL，将返回p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入</span><br><span class="line">void Insert(LinkList &amp;L, int i, int x)&#123;</span><br><span class="line">LNode *p = GetElem(L,i-1);</span><br><span class="line">LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">void Delete(LinkList &amp;L, int i)&#123;</span><br><span class="line">if(i&lt;1 || i&gt;Length(L))</span><br><span class="line">cout&lt;&lt;&quot;delete failed: index is wrong.&quot;&lt;&lt;endl;</span><br><span class="line">return;</span><br><span class="line">LNode *p = GetElem(L,i-1);</span><br><span class="line">LNode *q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">free(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判空</span><br><span class="line">bool Empty(LinkList L)&#123;</span><br><span class="line">    if(L-&gt;next == NULL)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;L is null&quot;&lt;&lt;endl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">else&#123;</span><br><span class="line">        cout &lt;&lt;&quot;L is not null&quot;&lt;&lt;endl;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
